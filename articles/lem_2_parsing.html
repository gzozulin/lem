<html>
    <style>

        .code,.child {
                    border-radius: 3px;
                    display: block;
                    max-width: 100%;
                    overflow: auto;
                    color: #666;
                    page-break-inside: avoid;
                    font: normal 15px/1.6 monospace;
                    padding: 1em 1.5em;
                    margin: 1.6em 0;
                    word-wrap: break-word;
                }

                .child {
                    border-radius: 3px;
                    background: #F1ECEC;
                    box-shadow: -5px 5px 10px rgba(0,0,0,0.3);
                }

                .code {
                    white-space: pre-wrap;
                    background: #EBFCE3;
                }

                .code_child {
                    border-radius: 3px;
                    white-space: pre-wrap;
                    background: #EBFCE3;
                    padding: 1em 1.5em;
                    margin: 1.6em 0;
                }

                .text {}
                .text_child {}

                .link {}
                .link_child {}

                .picture {
                    display: block;
                    margin: 30px auto 45px auto;
                    max-height: 50%;
                }
                .picture_child {}

                .list_item {}
                .list_item_child {}
    </style>
    <body>
        <h2 id="Contents">Contents</h2><ul class="list_item"><li>    <a class="link" href="#The-Parsing-Stage">The Parsing Stage</a>
</li></ul><h2 id="The-Parsing-Stage">The Parsing Stage</h2>
<p class="text">In this chapter, we will see the details of the parsing of the scenario. Parsing of a modern programming language is an incredibly complex task. And this task is far outside of the reach of this article. If you need to parse multiple languages and formats, the complexity of this task can easily outweigh the joy from the project.
</p><p class="text">
</p><p class="text">To avoid unnecessary complexity and to facilitate parsing, we will be using a tool called ANTLR4<sup id="1_origin"><a href="#1">&#91;1&#93;</a></sup>. What is especially good about this tool is that it comes with already available grammar for most of the modern<sup id="2_origin"><a href="#2">&#91;2&#93;</a></sup>. Those grammars are contributed and supported by people who are highly proficient with the languages in question.
</p><p class="text">
</p><p class="text">
</p><p class="text">We will employ two grammar files for our task at hand. One is for Kotlin language<sup id="3_origin"><a href="#3">&#91;3&#93;</a></sup>, and another is our custom grammar, which allows us to separate the code from the comments. If we would like to add the support for languages, other than Kotlin in the future, we always can do this by expanding the pool of available grammar.
</p><p class="text">
</p><p class="text">
</p><p class="text">I will not discuss the creation of the grammars and how to use ANTLR4 because it is outside of the scope of this article. For simplicity, we can think about it as if some tool will convert the provided language constructs into the classes, available for consumption in the language of our choice - in our case - Kotlin.
</p><p class="text">
</p><p class="text">Let us start with a first step - parsing of the scenario file, passed from the input arguments.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L21" target="_blank">com.blaster.business.InteractorParse::parseScenario</a>
</h3>
    <p class="text_child">This call will convert a scenario file into a list of nodes. The parameters are self explanatory.
</p><pre><code class="lang-kotlin">fun parseScenario(root: File, sourceUrl: URL, scenario: File): List&lt;Node&gt; {</code></pre>
<p class="text_child">First operation of this method is to convert text in the scenario file into a distinct nodes. Paragraphs are separated by the new lines
</p><pre><code class="lang-kotlin">    val nodes = scenario.readText().lines().map { NodeText(it) }</code></pre>
<p class="text_child">The next task is to apply common procedures for the nodes: identification and application of commands, identification of the structures
</p><pre><code class="lang-kotlin">    return renderNodes(root, sourceUrl, nodes)</code></pre>
<div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L47" target="_blank">com.blaster.business.InteractorParse::renderNodes</a>
</h3>
    <pre><code class="lang-kotlin">private fun renderNodes(root: File, sourceUrl: URL, nodes: List&lt;Node&gt;): List&lt;Node&gt; {
    val withCommands = interactorCommands.identifyCommands(root, sourceUrl, nodes)
    val commandsApplied = interactorCommands.applyCommands(root, sourceUrl, withCommands)
    return interactorStructs.identifyStructs(commandsApplied)
}</code></pre>

</div>
<pre><code class="lang-kotlin">}</code></pre>

</div>
<p class="text">
</p><p class="text">The scenario will produce a list of nodes and commands, which were identified. Let's see how the identification of the commands works.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorCommands.kt#L24" target="_blank">com.blaster.business.InteractorCommands::identifyCommand</a>
</h3>
    <p class="text_child">Main commands identification routine. Will return a command if identified, or null if nothing found
</p><pre><code class="lang-kotlin">private fun identifyCommand(root: File, sourceUrl: URL, command: String): NodeCommand? {</code></pre>
<p class="text_child">We prefix all of the commands in the text with a <span style="font-weight:bold">#</span> symbol. If it is not found - it is not a command
</p><pre><code class="lang-kotlin">    if (!command.startsWith(COMMAND_IDENTIFIER)) {
        return null
    }</code></pre>
<p class="text_child">Removing the prefix and converting a command into a stack of words
</p><pre><code class="lang-kotlin">    val noPrefix = command.removePrefix(COMMAND_IDENTIFIER)
    val stack = noPrefix.splitCsv()
    val cmd = stack[0]
    val subcmd = stack.subList(1, stack.size)</code></pre>
<p class="text_child">Then identifying each command family by command name. We remove the head of the stack each time when we go to the next level. Each command family will be parsed in the similar fashion, until nothing is left on the stack
</p><pre><code class="lang-kotlin">    return when {
        cmd == COMMAND_INCLUDE -&gt; identifyIncludeCommand(root, sourceUrl, subcmd)
        cmd == COMMAND_HEADER -&gt; identifyHeaderCommand(subcmd)
        cmd == COMMAND_PICTURE -&gt; identifyPictureCommand(subcmd)
        cmd == COMMAND_INLINE -&gt; identifyInlineCommand(root, sourceUrl, subcmd)
        cmd == COMMAND_OMIT -&gt; identifyOmitCommand()
        cmd == COMMAND_CITE -&gt; identifyCiteCommand(subcmd)
        cmd == COMMAND_CONTENT -&gt; identifyContentCommand(subcmd)
        else -&gt; TODO()
    }
}</code></pre>

</div>
<p class="text">
</p><p class="text">After the commands are identified, we can finally apply them.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorCommands.kt#L93" target="_blank">com.blaster.business.InteractorCommands::applyCommands</a>
</h3>
    <p class="text_child">Commands application routine. It receives a source url and root and a list of nodes as a parameters. The result is a list of nodes modified by all of the commands in the original list.
</p><pre><code class="lang-kotlin">fun applyCommands(root: File, sourceUrl: URL, nodes: List&lt;Node&gt;): List&lt;Node&gt; {</code></pre>
<p class="text_child">Since we will do operations on the list, we want to convert it to a mutable one - the structure of the list can be changed this way
</p><pre><code class="lang-kotlin">    val mutableList = ArrayList(nodes)
    val iterator = mutableList.listIterator()</code></pre>
<p class="text_child">We iterate over the list until we reached the end
</p><pre><code class="lang-kotlin">    while (iterator.hasNext()) {
        val node = iterator.next()</code></pre>
<p class="text_child">If the next item in the list is a command
</p><pre><code class="lang-kotlin">        if (node is NodeCommand) {
            when (node.cmdType) {</code></pre>
<p class="text_child">We apply the command accordingly
</p><pre><code class="lang-kotlin">                CmdType.INCLUDE -&gt; applyIncludeCommand(root, sourceUrl, iterator, node)
                CmdType.OMIT -&gt; applyOmitCommand(iterator)
                CmdType.INLINE -&gt; applyInlineCommand(root, sourceUrl, iterator, node)</code></pre>
<p class="text_child">Some commands have meaning only for printing, so we do nothing right now
</p><pre><code class="lang-kotlin">                else -&gt; {}
            }
        }
    }</code></pre>
<p class="text_child">Returning the modified result
</p><pre><code class="lang-kotlin">    return mutableList
}</code></pre>

</div>
<p class="text">
</p><p class="text">As we already know, some commands will request to include the additional code to showcase the mechanics. Such a command will have a command name, command arguments, and the path of the code to be included. Here is the code, responsible for locating the snippets:
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorLocation.kt#L14" target="_blank">com.blaster.business.InteractorLocation::locate</a>
</h3>
    <p class="text_child">This routine helps us to locate pieces of code, pointed out by path parameter. It returns a class, which represents the location of the found snippet.
</p><pre><code class="lang-kotlin">fun locate(root: File, sourceUrl: URL, path: String): Location {</code></pre>
<p class="text_child">First of all we want to assert if the path is formatted properly. This allows to highlight errors early
</p><pre><code class="lang-kotlin">    check(regexPath.find(path)!!.value.length == path.length) { &quot;Wrong path for the location: $path&quot; }</code></pre>
<p class="text_child">We start by extracting module from path if we have one
</p><pre><code class="lang-kotlin">    val (module, modulePath) = extractModule(path)</code></pre>
<p class="text_child">Then the class follows - we simply grabs everything before <span style="font-weight:bold">:</span>
</p><pre><code class="lang-kotlin">    val clazz = extractClass(modulePath)</code></pre>
<p class="text_child">Now we want to extract filepath to help us with file an url
</p><pre><code class="lang-kotlin">    val filepath = extractFilepath(clazz)</code></pre>
<p class="text_child">Next we want to retrieve the actual file, containing the class. We do that by looking at the sources root and a package
</p><pre><code class="lang-kotlin">    val file = locateFile(module, root, filepath)</code></pre>
<p class="text_child">We also want to assemble the URL to the location based source url on Github
</p><pre><code class="lang-kotlin">    val url = constructUrl(sourceUrl, module, filepath)</code></pre>
<p class="text_child">If the path contains exact member - extract it. If not - it is the same class
</p><pre><code class="lang-kotlin">    val identifier = extractIdentifier(path)
    return Location(file, identifier, url)
}</code></pre>

</div>
<p class="text">
</p><p class="text">The author of the scenario can choose how to include the code. We can either include definitions of declarations of methods and classes. The difference is that sometimes you want to include the body of the method, and sometimes you just want to mention it. Let us see how parsing of the requested definitions works.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L30" target="_blank">com.blaster.business.InteractorParse::parseDef</a>
</h3>
    <p class="text_child">Routine for parsing of the definitions. Accepts the sources url and root and a location of the definition. Returns a list of nodes for this definition (commentaries, code, commands, etc.)
</p><pre><code class="lang-kotlin">fun parseDef(root: File, sourceUrl: URL, location: Location): List&lt;Node&gt; {</code></pre>
<p class="text_child">When the definition is located, we extract the code with the help of the ANTLR4
</p><pre><code class="lang-kotlin">    val definition = kotlinManager.extractDefinition(location)</code></pre>
<p class="text_child">Next step is to split this text onto the commentaries and code snippets. We also format them - removing unused lines, spaces, etc.
</p><pre><code class="lang-kotlin">    val withoutTabulation = definition.clearCode()
    val statements = statementsManager.extractStatements(withoutTabulation, &quot;kotlin&quot;)
    return renderNodes(root, sourceUrl, statements)</code></pre>
<div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L47" target="_blank">com.blaster.business.InteractorParse::renderNodes</a>
</h3>
    <pre><code class="lang-kotlin">private fun renderNodes(root: File, sourceUrl: URL, nodes: List&lt;Node&gt;): List&lt;Node&gt; {
    val withCommands = interactorCommands.identifyCommands(root, sourceUrl, nodes)
    val commandsApplied = interactorCommands.applyCommands(root, sourceUrl, withCommands)
    return interactorStructs.identifyStructs(commandsApplied)
}</code></pre>

</div>
<pre><code class="lang-kotlin">}</code></pre>

</div>
<p class="text">
</p><p class="text">Parsing of the requested declarations works very similarly to definitions.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L40" target="_blank">com.blaster.business.InteractorParse::parseDecl</a>
</h3>
    <pre><code class="lang-kotlin">fun parseDecl(root: File, sourceUrl: URL, location: Location): List&lt;Node&gt; {
    val declaration = kotlinManager.extractDeclaration(location)
    val withoutTabulation = declaration.clearCode()
    val statements = statementsManager.extractStatements(withoutTabulation, &quot;kotlin&quot;)
    return renderNodes(root, sourceUrl, statements)
}</code></pre>

</div>
<p class="text">
</p><p class="text">Couple of words should be said about identifying the structures among the text. After all of the text pieces are located, we want to check if they contain any kind of lists, tables, links, spans and etc.:
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L31" target="_blank">com.blaster.business.InteractorStructs::identifyStructs</a>
</h3>
    <p class="text_child">This routine will kickstart the process of identification of formatting inside of the TextNode. The identification is based on the regular expressions checks. If a certain regular expression is found, we extract pieces of text with the appropriate formatting
</p><pre><code class="lang-kotlin">fun identifyStructs(nodes: List&lt;Node&gt;): List&lt;Node&gt; = nodes.map {
    when (it) {
        is NodeText -&gt; {
            val transformed = mutableListOf&lt;Node&gt;()</code></pre>
<p class="text_child">If the node is TextNode, we are trying to identify list items among the text
</p><pre><code class="lang-kotlin">            transformed.addAll(identifyListItems(it))
            it.copy(children = transformed)
        }
        else -&gt; it
    }
}</code></pre>

</div>
<p class="text">
</p><p class="text">We sequentially check if the remaining text contains any of the above mentioned in the following order:
</p><p class="text">
</p><p class="text"><ul class="list_item"><li>We try to identify list items first
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L43" target="_blank">com.blaster.business.InteractorStructs::identifyListItems</a>
</h3>
    <pre><code class="lang-kotlin">private fun identifyListItems(node: NodeText): List&lt;Node&gt; {
    val match = regexListItem.find(node.text)
    return if (match != null) {</code></pre>
<p class="text_child">We can have links inside of the list items
</p><pre><code class="lang-kotlin">        listOf(StructListItem(identifyLinks(match.groups[1]!!.value)))
    } else {</code></pre>
<p class="text_child">Or inside of any text
</p><pre><code class="lang-kotlin">        identifyLinks(node.text)
    }
}</code></pre>

</div>
<p class="text">
</p><p class="text"><ul class="list_item"><li>Then we go for the links
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L54" target="_blank">com.blaster.business.InteractorStructs::identifyLinks</a>
</h3>
    <pre><code class="lang-kotlin">private fun identifyLinks(text: String): List&lt;Node&gt; {
    val result = mutableListOf&lt;Node&gt;()
    identifySpansInText(text, regexLink) { span: String, isInside: Boolean -&gt;
        val node = if (isInside) {
            listOf(parseLink(span))
        } else {</code></pre>
<p class="text_child">If text is not a part of the link, it still can contain references to the other sources
</p><pre><code class="lang-kotlin">            identifyCites(span)
        }
        result.addAll(node)
    }
    return result
}</code></pre>

</div>
<p class="text">
</p><p class="text"><ul class="list_item"><li>Then we check for the references marks
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L68" target="_blank">com.blaster.business.InteractorStructs::identifyCites</a>
</h3>
    <pre><code class="lang-kotlin">private fun identifyCites(text: String): List&lt;Node&gt; {
    val result = mutableListOf&lt;Node&gt;()
    identifySpansInText(text, regexCite) { span: String, isInside: Boolean -&gt;
        val node = if (isInside) {
            StructCite(span)
        } else {</code></pre>
<p class="text_child">If we have just a piece of a text, we want to identify spans if any
</p><pre><code class="lang-kotlin">            StructText(identifySpans(span))
        }
        result.add(node)
    }
    return result
}</code></pre>

</div>
<p class="text">
</p><p class="text"><ul class="list_item"><li>And finally we are looking for formatting in the text
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L82" target="_blank">com.blaster.business.InteractorStructs::identifySpans</a>
</h3>
    <pre><code class="lang-kotlin">private fun identifySpans(text: String): List&lt;Node&gt; {
    val result = mutableListOf&lt;Node&gt;()
    identifySpansInText(text, regexBold) { span: String, isInside: Boolean -&gt;
        if (isInside) {</code></pre>
<p class="text_child">Currently, we support only bold or normal text
</p><pre><code class="lang-kotlin">            result.add(SpanText(span, SpanText.Style.BOLD))
        } else {
            result.add(SpanText(span, SpanText.Style.NORMAL))
        }
    }
    return result
}</code></pre>

</div>
<p class="text">
</p><p class="text">After all of the commands are executed and the snippets of the code are included from the repository, the commentaries in the code could contain additional commands. In this case, we will recursively go back to the stage of the commands and repeat the process.
</p><p class="text">
</p><p class="text">Finally, after all of that is done, we should have a result of the parsing stage - a list of nodes, which represents our article. This result will be passed to the next step, which is the printing of the article. We will have a look at the details of the printing in the next chapter.
</p><h2 id="References">References</h2><ul class="list_item"><li>    <a class="link" href="#1_origin">&#8593;[1]: </a>
<a id="1" class="link" href="https://github.com/antlr/antlr4" target="_blank">ANTLR4 on Github</a></li></ul><ul class="list_item"><li>    <a class="link" href="#2_origin">&#8593;[2]: </a>
<a id="2" class="link" href="https://github.com/antlr/grammars-v4" target="_blank">Grammars for ANTLR4 on Github</a></li></ul><ul class="list_item"><li>    <a class="link" href="#3_origin">&#8593;[3]: </a>
<a id="3" class="link" href="https://github.com/antlr/grammars-v4" target="_blank">Grammar for Kotlin on Github</a></li></ul>
        <br>
    </body>
</html>