<html>
    <style>

        .code,.child {
                    border-radius: 3px;
                    display: block;
                    max-width: 100%;
                    overflow: auto;
                    color: #666;
                    page-break-inside: avoid;
                    font: normal 15px/1.6 monospace;
                    padding: 1em 1.5em;
                    margin: 1.6em 0;
                    word-wrap: break-word;
                }

                .child {
                    border-radius: 3px;
                    background: #F1ECEC;
                    box-shadow: -5px 5px 10px rgba(0,0,0,0.3);
                }

                .code {
                    white-space: pre-wrap;
                    background: #EBFCE3;
                }

                .code_child {
                    border-radius: 3px;
                    white-space: pre-wrap;
                    background: #EBFCE3;
                    padding: 1em 1.5em;
                    margin: 1.6em 0;
                }

                .text {}
                .text_child {}

                .link {}
                .link_child {}

                .picture {}
                .picture_child {}

                .list_item {}
                .list_item_child {}
    </style>
    <body>
            <h2>The Parsing Stage</h2>

<p class="text">In this chapter, we will see the details of the parsing of the scenario. Parsing of a modern programming language is an incredibly complex task. And this task is far outside of the reach of this article. If you need to parse multiple languages and formats, the complexity of this task can easily outweigh the joy from the project.
</p><p class="text">
</p><p class="text">To avoid unnecessary complexity and to facilitate parsing, we will be using a tool called ANTLR4<sup id="1_origin"><a href="#1">&#91;1&#93;</a></sup>. What is especially good about this tool is that it comes with already available grammar for most of the modern<sup id="2_origin"><a href="#2">&#91;2&#93;</a></sup>. Those grammars are contributed and supported by people who are highly proficient with the languages in question.
</p><p class="text">
</p><p class="text">
</p><p class="text">We will employ two grammar files for our task at hand. One is for Kotlin language<sup id="3_origin"><a href="#3">&#91;3&#93;</a></sup>, and another is our custom grammar, which allows us to separate the code from the comments. If we would like to add the support for languages, other than Kotlin in the future, we always can do this by expanding the pool of available grammar.
</p><p class="text">
</p><p class="text">
</p><p class="text">I will not discuss the creation of the grammars and how to use ANTLR4 because it is outside of the scope of this article. For simplicity, we can think about it as if some tool will convert the provided language constructs into the classes, available for consumption in the language of our choice - in our case - Kotlin.
</p><p class="text">
</p><p class="text">Let us start with a first step - parsing of the scenario file, passed from the input arguments.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L21" target="_blank">com.blaster.business.InteractorParse::parseScenario</a>
</h3>
    <p class="text_child">This call will convert a scenario file into a list of nodes. The parameters are self explanatory.
</p><p class="code_child">fun parseScenario(root: File, sourceUrl: URL, scenario: File): List&lt;Node&gt; {</p>
<p class="text_child">First operation of this method is to convert text in the scenario file into a distinct nodes. Paragraphs are separated by the new lines
</p><p class="code_child">    val nodes = scenario.readText().lines().map { NodeText(it) }</p>
<p class="text_child">The next task is to apply common procedures for the nodes: identification and application of commands, identification of the structures
</p><p class="code_child">    return renderNodes(root, sourceUrl, nodes)</p>
<div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L47" target="_blank">com.blaster.business.InteractorParse::renderNodes</a>
</h3>
    <p class="code_child">private fun renderNodes(root: File, sourceUrl: URL, nodes: List&lt;Node&gt;): List&lt;Node&gt; {
    val withCommands = interactorCommands.identifyCommands(root, sourceUrl, nodes)
    val commandsApplied = interactorCommands.applyCommands(root, sourceUrl, withCommands)
    return interactorStructs.identifyStructs(commandsApplied)
}</p>

</div>
<p class="code_child">}</p>

</div>
<p class="text">
</p><p class="text">The scenario will produce a list of nodes and commands, which were identified. Let's see how the identification of the commands works.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorCommands.kt#L24" target="_blank">com.blaster.business.InteractorCommands::identifyCommand</a>
</h3>
    <p class="text_child">Main commands identification routine. Will return a command if identified, or null if nothing found
</p><p class="code_child">private fun identifyCommand(root: File, sourceUrl: URL, command: String): NodeCommand? {</p>
<p class="text_child">We prefix all of the commands in the text with a <span style="font-weight:bold">#</span> symbol. If it is not found - it is not a command
</p><p class="code_child">    if (!command.startsWith(COMMAND_IDENTIFIER)) {
        return null
    }</p>
<p class="text_child">Removing the prefix and converting a command into a stack of words
</p><p class="code_child">    val noPrefix = command.removePrefix(COMMAND_IDENTIFIER)
    val stack = noPrefix.splitCsv()
    val cmd = stack[0]
    val subcmd = stack.subList(1, stack.size)</p>
<p class="text_child">Then identifying each command family by command name. We remove the head of the stack each time when we go to the next level. Each command family will be parsed in the similar fashion, until nothing is left on the stack
</p><p class="code_child">    return when {
        cmd == COMMAND_INCLUDE -&gt; identifyIncludeCommand(root, sourceUrl, subcmd)
        cmd == COMMAND_HEADER -&gt; identifyHeaderCommand(subcmd)
        cmd == COMMAND_PICTURE -&gt; identifyPictureCommand(subcmd)
        cmd == COMMAND_INLINE -&gt; identifyInlineCommand(root, sourceUrl, subcmd)
        cmd == COMMAND_OMIT -&gt; identifyOmitCommand()
        cmd == COMMAND_CITE -&gt; identifyCiteCommand(subcmd)
        else -&gt; TODO()
    }
}</p>

</div>
<p class="text">
</p><p class="text">After the commands are identified, we can finally apply them.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorCommands.kt#L94" target="_blank">com.blaster.business.InteractorCommands::applyCommands</a>
</h3>
    <p class="text_child">Commands application routine. It receives a source url and root and a list of nodes as a parameters. The result is a list of nodes modified by all of the commands in the original list.
</p><p class="code_child">fun applyCommands(root: File, sourceUrl: URL, nodes: List&lt;Node&gt;): List&lt;Node&gt; {</p>
<p class="text_child">Since we will do operations on the list, we want to convert it to a mutable one - the structure of the list can be changed this way
</p><p class="code_child">    val mutableList = ArrayList(nodes)
    val iterator = mutableList.listIterator()</p>
<p class="text_child">We iterate over the list until we reached the end
</p><p class="code_child">    while (iterator.hasNext()) {
        val node = iterator.next()</p>
<p class="text_child">If the next item in the list is a command
</p><p class="code_child">        if (node is NodeCommand) {
            when (node.cmdType) {</p>
<p class="text_child">We apply the command accordingly
</p><p class="code_child">                CmdType.INCLUDE -&gt; applyIncludeCommand(root, sourceUrl, iterator, node)
                CmdType.OMIT -&gt; applyOmitCommand(iterator)
                CmdType.INLINE -&gt; applyInlineCommand(root, sourceUrl, iterator, node)</p>
<p class="text_child">Some commands have meaning only for printing, so we do nothing right now
</p><p class="code_child">                else -&gt; {}
            }
        }
    }</p>
<p class="text_child">Returning the modified result
</p><p class="code_child">    return mutableList
}</p>

</div>
<p class="text">
</p><p class="text">As we already know, some commands will request to include the additional code to showcase the mechanics. Such a command will have a command name, command arguments, and the path of the code to be included. Here is the code, responsible for locating the snippets:
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorLocation.kt#L14" target="_blank">com.blaster.business.InteractorLocation::locate</a>
</h3>
    <p class="text_child">This routine helps us to locate pieces of code, pointed out by path parameter. It returns a class, which represents the location of the found snippet.
</p><p class="code_child">fun locate(root: File, sourceUrl: URL, path: String): Location {</p>
<p class="text_child">First of all we want to assert if the path is formatted properly. This allows to highlight errors early
</p><p class="code_child">    check(regexPath.find(path)!!.value.length == path.length) { &quot;Wrong path for the location: $path&quot; }</p>
<p class="text_child">We start by extracting module from path if we have one
</p><p class="code_child">    val (module, modulePath) = extractModule(path)</p>
<p class="text_child">Then the class follows - we simply grabs everything before <span style="font-weight:bold">:</span>
</p><p class="code_child">    val clazz = extractClass(modulePath)</p>
<p class="text_child">Now we want to extract filepath to help us with file an url
</p><p class="code_child">    val filepath = extractFilepath(clazz)</p>
<p class="text_child">Next we want to retrieve the actual file, containing the class. We do that by looking at the sources root and a package
</p><p class="code_child">    val file = locateFile(module, root, filepath)</p>
<p class="text_child">We also want to assemble the URL to the location based source url on Github
</p><p class="code_child">    val url = constructUrl(sourceUrl, module, filepath)</p>
<p class="text_child">If the path contains exact member - extract it. If not - it is the same class
</p><p class="code_child">    val identifier = extractIdentifier(path)
    return Location(url, file, identifier)
}</p>

</div>
<p class="text">
</p><p class="text">The author of the scenario can choose how to include the code. We can either include definitions of declarations of methods and classes. The difference is that sometimes you want to include the body of the method, and sometimes you just want to mention it. Let us see how parsing of the requested definitions works.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L30" target="_blank">com.blaster.business.InteractorParse::parseDef</a>
</h3>
    <p class="text_child">Routine for parsing of the definitions. Accepts the sources url and root and a location of the definition. Returns a list of nodes for this definition (commentaries, code, commands, etc.)
</p><p class="code_child">fun parseDef(root: File, sourceUrl: URL, location: Location): List&lt;Node&gt; {</p>
<p class="text_child">When the definition is located, we extract the code with the help of the ANTLR4
</p><p class="code_child">    val definition = kotlinManager.extractDefinition(location)</p>
<p class="text_child">Next step is to split this text onto the commentaries and code snippets. We also format them - removing unused lines, spaces, etc.
</p><p class="code_child">    val withoutTabulation = definition.clearCode()
    val statements = statementsManager.extractStatements(withoutTabulation)
    return renderNodes(root, sourceUrl, statements)</p>
<div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L47" target="_blank">com.blaster.business.InteractorParse::renderNodes</a>
</h3>
    <p class="code_child">private fun renderNodes(root: File, sourceUrl: URL, nodes: List&lt;Node&gt;): List&lt;Node&gt; {
    val withCommands = interactorCommands.identifyCommands(root, sourceUrl, nodes)
    val commandsApplied = interactorCommands.applyCommands(root, sourceUrl, withCommands)
    return interactorStructs.identifyStructs(commandsApplied)
}</p>

</div>
<p class="code_child">}</p>

</div>
<p class="text">
</p><p class="text">Parsing of the requested declarations works very similarly to definitions.
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorParse.kt#L40" target="_blank">com.blaster.business.InteractorParse::parseDecl</a>
</h3>
    <p class="code_child">fun parseDecl(root: File, sourceUrl: URL, location: Location): List&lt;Node&gt; {
    val declaration = kotlinManager.extractDeclaration(location)
    val withoutTabulation = declaration.clearCode()
    val statements = statementsManager.extractStatements(withoutTabulation)
    return renderNodes(root, sourceUrl, statements)
}</p>

</div>
<p class="text">
</p><p class="text">Couple of words should be said about identifying the structures among the text. After all of the text pieces are located, we want to check if they contain any kind of lists, tables, links, spans and etc.:
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L31" target="_blank">com.blaster.business.InteractorStructs::identifyStructs</a>
</h3>
    <p class="text_child">This routine will kickstart the process of identification of formatting inside of the TextNode. The identification is based on the regular expressions checks. If a certain regular expression is found, we extract pieces of text with the appropriate formatting
</p><p class="code_child">fun identifyStructs(nodes: List&lt;Node&gt;): List&lt;Node&gt; = nodes.map {
    when (it) {
        is NodeText -&gt; {
            val transformed = mutableListOf&lt;Node&gt;()</p>
<p class="text_child">If the node is TextNode, we are trying to identify list items among the text
</p><p class="code_child">            transformed.addAll(identifyListItems(it))
            it.copy(children = transformed)
        }
        else -&gt; it
    }
}</p>

</div>
<p class="text">
</p><p class="text">We sequentially check if the remaining text contains any of the above mentioned in the following order:
</p><p class="text">
</p><p class="text"><ul class="list_item"><li>We try to identify list items first
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L43" target="_blank">com.blaster.business.InteractorStructs::identifyListItems</a>
</h3>
    <p class="code_child">private fun identifyListItems(node: NodeText): List&lt;Node&gt; {
    val match = regexListItem.find(node.text)
    return if (match != null) {</p>
<p class="text_child">We can have links inside of the list items
</p><p class="code_child">        listOf(StructListItem(identifyLinks(match.groups[1]!!.value)))
    } else {</p>
<p class="text_child">Or inside of any text
</p><p class="code_child">        identifyLinks(node.text)
    }
}</p>

</div>
<p class="text">
</p><p class="text"><ul class="list_item"><li>Then we go for the links
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L54" target="_blank">com.blaster.business.InteractorStructs::identifyLinks</a>
</h3>
    <p class="code_child">private fun identifyLinks(text: String): List&lt;Node&gt; {
    val result = mutableListOf&lt;Node&gt;()
    identifySpansInText(text, regexLink) { span: String, isInside: Boolean -&gt;
        val node = if (isInside) {
            listOf(parseLink(span))
        } else {</p>
<p class="text_child">If text is not a part of the link, it still can contain references to the other sources
</p><p class="code_child">            identifyCites(span)
        }
        result.addAll(node)
    }
    return result
}</p>

</div>
<p class="text">
</p><p class="text"><ul class="list_item"><li>Then we check for the references marks
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L68" target="_blank">com.blaster.business.InteractorStructs::identifyCites</a>
</h3>
    <p class="code_child">private fun identifyCites(text: String): List&lt;Node&gt; {
    val result = mutableListOf&lt;Node&gt;()
    identifySpansInText(text, regexCite) { span: String, isInside: Boolean -&gt;
        val node = if (isInside) {
            StructCite(span)
        } else {</p>
<p class="text_child">If we have just a piece of a text, we want to identify spans if any
</p><p class="code_child">            StructText(identifySpans(span))
        }
        result.add(node)
    }
    return result
}</p>

</div>
<p class="text">
</p><p class="text"><ul class="list_item"><li>And finally we are looking for formatting in the text
</li></ul>
</p><div class="child">
    <h3>    <a class="link_child" href="https://github.com/madeinsoviets/lem/blob/develop//src/main/kotlin/com/blaster/business/InteractorStructs.kt#L82" target="_blank">com.blaster.business.InteractorStructs::identifySpans</a>
</h3>
    <p class="code_child">private fun identifySpans(text: String): List&lt;Node&gt; {
    val result = mutableListOf&lt;Node&gt;()
    identifySpansInText(text, regexBold) { span: String, isInside: Boolean -&gt;
        if (isInside) {</p>
<p class="text_child">Currently, we support only bold or normal text
</p><p class="code_child">            result.add(SpanText(span, SpanText.Style.BOLD))
        } else {
            result.add(SpanText(span, SpanText.Style.NORMAL))
        }
    }
    return result
}</p>

</div>
<p class="text">
</p><p class="text">After all of the commands are executed and the snippets of the code are included from the repository, the commentaries in the code could contain additional commands. In this case, we will recursively go back to the stage of the commands and repeat the process.
</p><p class="text">
</p><p class="text">Finally, after all of that is done, we should have a result of the parsing stage - a list of nodes, which represents our article. This result will be passed to the next step, which is the printing of the article. We will have a look at the details of the printing in the next chapter.
</p><p class="text">
</p>    <h2>References</h2>

<ul class="list_item"><li>    <a class="link" href="#1_origin">&#8593;[1]: </a>
<a id="1" class="link" href="https://github.com/antlr/antlr4" target="_blank">ANTLR4 on Github</a></li></ul><ul class="list_item"><li>    <a class="link" href="#2_origin">&#8593;[2]: </a>
<a id="2" class="link" href="https://github.com/antlr/grammars-v4" target="_blank">Grammars for ANTLR4 on Github</a></li></ul><ul class="list_item"><li>    <a class="link" href="#3_origin">&#8593;[3]: </a>
<a id="3" class="link" href="https://github.com/antlr/grammars-v4" target="_blank">Grammar for Kotlin on Github</a></li></ul>
    </body>
</html>